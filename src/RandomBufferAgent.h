/*
 * Copyright (C) 2015 Cybernetica
 *
 * Research/Commercial License Usage
 * Licensees holding a valid Research License or Commercial License
 * for the Software may use this file according to the written
 * agreement between you and Cybernetica.
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU
 * General Public License version 3.0 as published by the Free Software
 * Foundation and appearing in the file LICENSE.GPL included in the
 * packaging of this file.  Please review the following information to
 * ensure the GNU General Public License version 3.0 requirements will be
 * met: http://www.gnu.org/copyleft/gpl-3.0.html.
 *
 * For further information, please contact us at sharemind@cyber.ee.
 */

#ifndef SHAREMINDCOMMON_RANDOMBUFFERAGENT_H
#define SHAREMINDCOMMON_RANDOMBUFFERAGENT_H

#include "IRandom.h"

#include <exception>
#include <sharemind/CircBufferSCSP.h>
#include <sharemind/PotentiallyVoidTypeInfo.h>
#include <sharemind/Stoppable.h>
#include <thread>


namespace sharemind {

/** This class is a header-only front-end for randomness engines. */
class RandomBufferAgent: public IRandom {

public: /* Methods: */

    inline RandomBufferAgent(IRandom & randomEngine,
                             const size_t bufferSize)
        : m_engine(randomEngine)
        , m_buffer(bufferSize)
        , m_thread(&RandomBufferAgent::fillerThread, this) {}

    inline ~RandomBufferAgent() noexcept override {
        m_stoppable.stop();
        m_thread.join();
    }

    inline void Seed() noexcept override {
        m_engine.Seed();
    }

    virtual void Seed(const void * memptr, size_t size) noexcept override {
        m_engine.Seed(memptr, size);
    }

    /**
     * \brief Fills memory with randomly generated bytes.
     * \param[in] memptr pointer to memory to fill
     * \param[in] size number of bytes to fill
     */
    void fillBytes(void * memptr, size_t size) noexcept override {
        for (;;) {
            const size_t read = m_buffer.read(memptr, size);
            assert(read <= size);
            if (read >= size)
                return;
            memptr = PotentiallyVoidTypeInfo<void>::ptrAdd(memptr, read);
            size -= read;
            m_buffer.waitDataAvailable();
        }
    }

private: /* Methods: */

    void fillerThread() noexcept {
        struct GracefulStop {};
        try {
            for (;;) {
                m_buffer.write(m_engine);
                m_buffer.waitSpaceAvailable(
                            Stoppable::TestActor<GracefulStop>{m_stoppable},
                            sharemind::StaticLoopDuration<10>{});
            }
        } catch (const GracefulStop &) {}
    }

private: /* Fields: */

    IRandom & m_engine;
    CircBufferSCSP<void> m_buffer;
    Stoppable m_stoppable;
    std::thread m_thread;

}; /* class IRandom { */

} /* namespace sharemind { */

#endif /* SHAREMINDCOMMON_RANDOMBUFFERAGENT_H */
