/*
 * Copyright (C) 2015 Cybernetica
 *
 * Research/Commercial License Usage
 * Licensees holding a valid Research License or Commercial License
 * for the Software may use this file according to the written
 * agreement between you and Cybernetica.
 *
 * GNU General Public License Usage
 * Alternatively, this file may be used under the terms of the GNU
 * General Public License version 3.0 as published by the Free Software
 * Foundation and appearing in the file LICENSE.GPL included in the
 * packaging of this file.  Please review the following information to
 * ensure the GNU General Public License version 3.0 requirements will be
 * met: http://www.gnu.org/copyleft/gpl-3.0.html.
 *
 * For further information, please contact us at sharemind@cyber.ee.
 */

#ifndef SHAREMINDCOMMON_IRANDOM_H
#define SHAREMINDCOMMON_IRANDOM_H

#include <algorithm>
#include <cassert>
#include <cstddef>
#include <exception>
#include <LogHard/Logger.h>
#include <sharemind/Exception.h>
#include <string>


namespace sharemind {

/** This class is a header-only front-end for randomness engines. */
class IRandom {

public: /* Types: */

    SHAREMIND_DEFINE_EXCEPTION_UNUSED(std::exception, Exception);

    /**
     * The randomness engine types available in the code.
     */
    enum Type {
        INVALID,
        /*! An engine based on the SNOW2 stream cipher */
        SNOW2,
        /*! An engine based on the OpenSSL RAND_bytes function */
        OPENSSL
    };

public: /* Methods: */

    virtual ~IRandom() noexcept {}

    virtual void Seed() noexcept = 0;

    virtual void Seed(const void * memptr, size_t size) noexcept = 0;

    /**
     * \brief Fills memory with randomly generated bytes.
     * \param[in] memptr pointer to memory to fill
     * \param[in] size number of bytes to fill
     */
    virtual void fillBytes(void * memptr, size_t size) noexcept = 0;

    template <typename T>
    inline void fillBlock(T * begin, T * end) noexcept {
        assert(begin <= end);
        if (begin < end)
            fillBytes(begin, sizeof(T)*std::distance(begin, end));
    }

    template <typename T>
    inline T randomValue() noexcept {
        T value;
        fillBytes(&value, sizeof(T));
        return value;
    }

    inline size_t operator()(void * memptr, size_t size) noexcept {
        fillBytes(memptr, size);
        return size;
    }

    static Type stringToRandomEngineType(const std::string & value)
            noexcept;

    static IRandom * newRandomEngine(const LogHard::Logger & logger,
                                     const Type type);

    static IRandom * newRandomEngine(const LogHard::Logger & logger,
                                     const std::string & type)
    { return newRandomEngine(logger, stringToRandomEngineType(type)); }

}; /* class IRandom { */

} /* namespace sharemind { */

#endif /* SHAREMINDCOMMON_IRANDOM_H */
